<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <title>Quadtree Visualization with Nodes</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #map-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Sigma.js graph at the bottom */
        }
        #quadtreeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Quadtree canvas on top, transparent background */
            pointer-events: none; /* Allow mouse events to pass through to Sigma.js */
            background: transparent; /* Ensure background is transparent */
        }
        .loading { /* Basic loading indicator */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            z-index: 3;
        }
    </style>

</head>
<body>
    <div class="loading">Loading Map and Quadtree...</div>
    <div id="map-container"></div>
    <canvas id="quadtreeCanvas"></canvas>

    <script type="module">

        import { fetchMapData } from './js/apiService.js';
        import { initMapRender } from './js/mapRenderer.js';
        // initEventListeners и createScaleInfo могут понадобиться, если main.js их использует
        // import { initEventListeners } from './js/eventHandlers.js';
        // import { createScaleInfo } from './js/uiUtils.js';


        const quadtreeCanvas = document.getElementById('quadtreeCanvas');
        const quadtreeCtx = quadtreeCanvas.getContext('2d');
        quadtreeCanvas.width = window.innerWidth;
        quadtreeCanvas.height = window.innerHeight;

        let sigmaInstance = null; // To store the Sigma instance for coordinate conversion

        async function fetchQuadtreeData() {
            try {
                const response = await fetch('/api/quadtree');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                return data.boundaries;
            } catch (error) {
                console.error('Failed to fetch quadtree data:', error);
                alert('Failed to fetch quadtree data!');
                return [];
            }
        }


        function drawQuadtreeBoundaries(boundaries) {
            quadtreeCtx.clearRect(0, 0, quadtreeCanvas.width, quadtreeCanvas.height);
            if (!sigmaInstance || boundaries.length === 0) return;

            boundaries.forEach(boundary => {
                const { x_min, y_min, x_max, y_max, level } = boundary;

                
                const p1 = sigmaInstance.graphToViewport({ x: x_min, y: y_min });
                const p2 = sigmaInstance.graphToViewport({ x: x_max, y: y_max });
                
                
                const screen_x_min = Math.min(p1.x, p2.x);
                const screen_y_min = Math.min(p1.y, p2.y);
                const screen_x_max = Math.max(p1.x, p2.x);
                const screen_y_max = Math.max(p1.y, p2.y);
                // console.log("实时缩放监听生效！！")

                quadtreeCtx.strokeStyle = `rgba(0,0,255,${0.2 + 0.8/(level+1)})`;
                quadtreeCtx.lineWidth = 1;
                quadtreeCtx.strokeRect(screen_x_min, screen_y_min, screen_x_max - screen_x_min, screen_y_max - screen_y_min);
            });
        }
        
        let allQuadtreeBoundaries = []; // Store all boundaries to redraw on zoom/pan
        let currentlyDrawingQuadtree = false;

        
        async function visualizeQuadtreeStepByStep() {
            if (currentlyDrawingQuadtree) return;
            currentlyDrawingQuadtree = true;

            allQuadtreeBoundaries = await fetchQuadtreeData();
            if (!sigmaInstance) { // Ensure sigma is initialized
                console.warn("Sigma instance not ready for quadtree drawing.");
                currentlyDrawingQuadtree = false;
                return;
            }

            const boundariesByLevel = {};
            allQuadtreeBoundaries.forEach(b => {
                if (!boundariesByLevel[b.level]) boundariesByLevel[b.level] = [];
                boundariesByLevel[b.level].push(b);
            });
            const maxLevel = Math.max(...Object.keys(boundariesByLevel).map(Number).filter(k => !isNaN(k)), -1);
            
            let currentLevel = 0;
            const drawnBoundaries = [];

            function drawNextLevel() {
                if (currentLevel <= maxLevel) {
                    const boundariesToDraw = boundariesByLevel[currentLevel] || [];
                    drawnBoundaries.push(...boundariesToDraw);
                    drawQuadtreeBoundaries(drawnBoundaries); // Draw cumulative boundaries
                    currentLevel++;
                    setTimeout(drawNextLevel, 500);
                } else {
                    console.log("Quadtree drawing complete.");
                    currentlyDrawingQuadtree = false;
                
                    if (sigmaInstance) {
                        sigmaInstance.getCamera().on("updated", () => {
                             drawQuadtreeBoundaries(drawnBoundaries); // Redraw all drawn boundaries
                        });
                    }
                }
            }
            drawNextLevel();
        }

        async function main() {
            try {
                
                const mapAPIData = await fetchMapData(); // from apiService.js

                
                // initMapRender должна вернуть объект, содержащий экземпляр renderer (Sigma)
                const mapRenderData = initMapRender(mapAPIData); // from mapRenderer.js
                
                if (mapRenderData && mapRenderData.renderer) {
                    sigmaInstance = mapRenderData.renderer;
                    
                    visualizeQuadtreeStepByStep();
                } else {
                    console.error("Failed to initialize map renderer or get Sigma instance.");
                    alert("Failed to initialize map renderer.");
                    return;
                }
                
                // 3. Удаляем индикатор загрузки
                const loadingElement = document.querySelector(".loading");
                if (loadingElement) {
                    loadingElement.remove();
                }
                console.log("Application and Quadtree visualization initialized.");

            } catch (error) {
                console.error("Application initialization failed:", error);
                const loadingElement = document.querySelector(".loading");
                if (loadingElement) {
                     loadingElement.textContent = "Application initialization failed, please refresh.";
                }
                alert("Application initialization failed. Check console.");
            }
        }

        // Адаптация к изменению размера окна
        window.addEventListener('resize', () => {
            quadtreeCanvas.width = window.innerWidth;
            quadtreeCanvas.height = window.innerHeight;
            // Sigma обычно сама адаптируется к изменению размера контейнера,
            // но нам нужно перерисовать квадродерево
            if (sigmaInstance && allQuadtreeBoundaries.length > 0) {
                 // Redraw all boundaries that were part of the step-by-step process
                 const drawnBoundariesCumulative = [];
                 const boundariesByLevel = {};
                 allQuadtreeBoundaries.forEach(b => {
                    if (!boundariesByLevel[b.level]) boundariesByLevel[b.level] = [];
                    boundariesByLevel[b.level].push(b);
                 });
                 const maxLevelDrawn = Math.max(...Object.keys(boundariesByLevel).map(Number).filter(k => !isNaN(k)), -1);
                 // This assumes visualizeQuadtreeStepByStep has a way to know how many levels were drawn
                 // For simplicity, let's assume we always redraw everything if resize happens after full draw.
                 // A more precise approach would be to track the 'currentLevel' of drawing.
                 drawQuadtreeBoundaries(allQuadtreeBoundaries);
            }
        });

        // Запуск приложения после загрузки DOM
        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html> 